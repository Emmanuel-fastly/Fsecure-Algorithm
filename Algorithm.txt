Project Description:
This project is about creating an encryption algorithm, heavily inspired by AES encryption algorithm. The implementation will be a symmetric encryption algorithm that will be known for its speed and security. The algorithm will be implemented using Python. Using 128-bit key, the algorithm will have three main steps: key expansion, encryption, and decryption. 

The key expansion step will produce ten new keys from the master key. The encryption step will apply each round key to the plaintext current state to produce a ciphertext, and apply the next round key to the current state until all the round keys are used. The decryption step will use the round keys to decrypt the ciphertext back to the original plaintext. 

The algorithm will also have additional steps to add more confusion and diffusion to the ciphertext. The additional steps will include generating a permutation secret key for each round key, permuting the columns of the current state in the order of the permutation secret key, and inverting the column permutation during decryption. The algorithm will also include the AES shift rows, AES sub bytes, and add round key steps. The algorithm will be tested using test cases to ensure that it is working correctly.

Algorithm steps:

1 Key expansion
    Using a 128-bit-key size, the original key is expanded into a set of round keys, which are used in the subsequent rounds of encryption and decryption. The inspiration for this step is from the AES key expansion. The key expansion added an additional step of generating a permutation secret key for each round key. The permutation secret key is used to permute the columns of the current state in the order of the permutation secret key. The permutation secret key is generated by selecting the first unique 4 bytes from each round key. 

        Steps:
            - Transform the key into four 32-bit word like in AES
            - Apply RtWord() function - Rotate the word in circular left shift 
            - Apply SubBytes() function - Substitute the bytes of the word using S-box  (Substitution box)   
            - Rcon constant to adding XOR - Apply XOR with the Rcon constant to the first word of the key
            - Apply XOR with the previous word - XOR the current word with the previous word in the key to produce the next word in the key 
            - Repeat the above steps for 10 rounds
        Additional steps:
            - Generate permutation secret key for each round key.
            Process:
                - For each generated round key, generate a permutation secret key by selecting the first unique 4 bytes from the round key. Example: If the round key is 0x1234567890ABCDEF, the permutation secret key will be 0x1234.


2 Encryption. The encryption step applys each round key to the plaintext current state to produce a ciphertext(a new current state), and apply the next round key to the current state until all the round keys are used (Excluding the master key, the key used to produce 10 roound keys).

    Steps:
        - AddRoundKey() function - XOR the current state with the round key
        - SubBytes() function - Each byte of the state matrix is replaced with a corresponding byte from a predefined substitution table (S-box). This step introduces non-linearity into the encryption process.
        - ShiftRows() function - The bytes in each row of the state matrix are shifted cyclically to the left. This step provides diffusion and ensures that each byte influences multiple ciphertext bytes.
    Additional steps:
    - Row_Column Transposition function - Permute the columns of the current state in the order of the permutation secret key.
        Process:
            - For each round, permute the current state of plaintext by spreading the state in a 4x4 matrix and use the permu_secret as the order of the column. The plaintext or the current state is written in rows and read in columns. The permu_secret is used to read the columns in the order of the permu_secret.
    - AddRoundKey() function - XOR the current state with the round key
    - Repeat the above steps for remaining rounds - 9 rounds

3 Decryption. The third step will be to perform the decryption using the round keys on the ciphertext.
    Steps:

    - AddRoundKey() function - XOR the current state with the round key
    - InverseRowColumn Transposition() function - Inverse the column permutation
    - InverseShiftRows() function - Inverse the shift rows of the current state
    - InverseSubBytes() function - Inverse the substitution of the bytes of the current state
    - Repeat the above steps for 9 rounds

Program:
Key Expansion
Permutation Secret Key Generation
Encryption Steps:
    Round Key Generation
    AES Shift Rows
    AES Sub Bytes
    Row Column Permutation
    Add Round Key
    Repeat the above steps for 9 rounds(Round Encryption)
Decryption Steps:
    Add Round Key
    Inverse Row Column Transposition
    Inverse Shift Rows
    Inverse Sub Bytes
    Repeat the above steps for 9 rounds(Round Decryption)
